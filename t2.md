# Adding event handlers to the controls
Note that the preceding XAML code implements the visual layer of the DrumPad using WinUI 3 controls. However, if you click on any buttons, nothing happens, because we have not defined any actions, which we will do in this blog. In this blog, you will be guided to accomplish the following: 
* Play a sound when a drum pad button is clicked
* Go into a specific windowing mode when something from the drop-down box is selected
* Switch to dark mode when the dark mode toggle is on


## Play a sound when a drum pad button is clicked
Explanation for why you will need a NuGet Package (To play a sound, you should download some sound clips to your folder). If you would like to use mine, simply download them here. However, to play a sound in WinUI apps, you will need to use a libaary called System.Media. It’s not in Visual Studio by default, so you will need to download a NuGet Packages in order to use it.
* Navigate to Solution Explorer, under Dependencies, right-click Packages, select Manage NuGet Packages (Screenshot guidance) 
* Within the Browse tab, search System.Windows.Extensions and install it
* Add any .wav sound clips to your project’s Assets folder, or optionally use my sound clips for simplicity here


1.	Add the following namespace to the MainAppWindow.xaml.cs file:
```csharp
using System.Media;
```

2.	Create a call-back function that plays a sound inside class MainWindow : Window
```csharp
private void pad_clicked(object sender, RoutedEventArgs e)
{
    // get the full path to your app’s folder where it is installed
    var installedPath = Windows.ApplicationModel.Package.Current.InstalledLocation.Path;
    // join path above with the sub-paths in your Assets folder and the specific sound file
    var soundFile = Path.Join(installedPath, "Assets", "rim.wav");

    SoundPlayer player = new System.Media.SoundPlayer(soundFile);
    player.Play();
}
```


3.	link a desired Button from the bottom grid to the call-back function to invoke it when that button is clicked in the MainWindow.xaml file:
```xml
<Button Grid.Row="0" Grid.Column="0" … … Click="pad_clicked" />
```



Repeat step 2 and 3 to attach another sound clip to a different button until all 9 buttons map to some sound clips of your desire! For your reference, check out my MainWindow.xaml.cs and MainWindow.xaml files.

## Implementing dark mode
The dark mode is an app appearance where the content is laid out on a dark background. It improves readability, especially in a low-light environment, and give the app a different aesthetic appearance.

1.	Define Light and Dark themes in App.xaml: 
```xml
<ResourceDictionary.ThemeDictionaries>
    <ResourceDictionary x:Key="Light">

    </ResourceDictionary>
    <ResourceDictionary x:Key="Dark">

    </ResourceDictionary>
</ResourceDictionary.ThemeDictionaries>
```


2.	Add these SolidColorBrush to the Light and Dark Mode:
```xml
<ResourceDictionary.ThemeDictionaries>
    <ResourceDictionary x:Key="Light">
        <SolidColorBrush x:Key="HomePageBackgroundBrush" Color="Transparent"/>
        <SolidColorBrush x:Key="PageHeaderForegroundBrush" Color="Black"/>
        <SolidColorBrush x:Key="ButtonColor1" Color="Red" />

    </ResourceDictionary>
    <ResourceDictionary x:Key="Dark">
        <SolidColorBrush x:Key="HomePageBackgroundBrush" Color="Black"/>
        <SolidColorBrush x:Key="PageHeaderForegroundBrush" Color="White"/>
        <SolidColorBrush x:Key="ButtonColor1" Color="DarkRed"  />
    </ResourceDictionary>
</ResourceDictionary.ThemeDictionaries>
```


3.	Specify a theme on the outermost grid in MainWindow.xaml: 
```xml
<Grid Background="{ThemeResource HomePageBackgroundBrush}">
```

4.	Define ToggleSwitch action in MainWinow.xaml.cs:
```csharp
private void ToggleSwitch_Toggled(object sender, RoutedEventArgs e)
{
    ToggleSwitch toggleSwitch = sender as ToggleSwitch;
    if (toggleSwitch != null)
    {
        if (toggleSwitch.IsOn == true)
        {
            if (this.Content is FrameworkElement frameworkElement)
            {
                frameworkElement.RequestedTheme = ElementTheme.Dark;
            }
        }
        else
        {
            if (this.Content is FrameworkElement frameworkElement)
            {
                frameworkElement.RequestedTheme = ElementTheme.Light;
            }
        }
    }
}
```

5.	Add above call back function to ToggleSwitch in MainWindow.xaml:
```xml
<ToggleSwitch … … Toggled="ToggleSwitch_Toggled" />
```


> **Optional**: You can save the state of the theme resource and persist the option the user chose at the next app launch
1.	Save the requested theme in local app settings in Toggle_Switch_Toggled:

```csharp
private void ToggleSwitch_Toggled(object sender, RoutedEventArgs e)
{
    ToggleSwitch toggleSwitch = sender as ToggleSwitch;
    if (toggleSwitch != null)
    {
        …
    }

    ApplicationData.Current.LocalSettings.Values["themeSetting"] = ((ToggleSwitch)sender).IsOn ? 0 : 1;
}
```


2.	Retrieve the saved theme setting when the app is restarted
```csharp
private void ToggleSwitch_Loaded(object sender, RoutedEventArgs e)
{
    if (ApplicationData.Current.LocalSettings.Values.TryGetValue("themeSetting", out object themeSetting) && (int)themeSetting == 0)
    {
        dark_switch.IsOn = true;
    } else
    {
        dark_switch.IsOn = false;
    }
}
```

3.	Apply the saved theme setting when the app is restarted in MainWindow.xaml: 
```xml
<ToggleSwitch … Toggled="ToggleSwitch_Toggled" Loaded="ToggleSwitch_Loaded"/>
```


Lauch the app again, you can switch between light/dark theme. You should see your choice for the theme is restored if you launch the app again.


## Managing window display
Using the Windowing features in WinAppSDK provides a lot of flexibility and customization to your app experience. One of these customization features is the ability to change the Presenter mode of your window. There are 3 presenters you can use: Compact  Overlay, Fullscreen, and Overlapped mode, with overlapped being the default presenter. Through this tutorial, you will learn how to display a picture that shows the change in experience from regular window to compact overlay. This will make this app window to always appear on top of - unblocked by other app windows.  

> **NOTE**: It’s worth mentioning that when we build and run the project solution, there will already be some functionalities like minimizing, maximizing, and closing the app window in the title bar.

1.	Add the following namespaces in MainWindow.xaml.cs file:
```csharp
using WinRT;
// Needed for WindowId
using Microsoft.UI;
// Needed for AppWindow
using Microsoft.UI.Windowing;
// Needed for XAML hwnd interop
using WinRT.Interop;
```

2.	Declare the following variables inside the class of class MainWindow : Window:
```csharp
AppWindow m_appWindow;
CompactOverlayPresenter c;
```

3.	Define a helper function GetAppWindowForCurrentWindow:
```csharp
private AppWindow GetAppWindowForCurrentWindow()
{
    IntPtr hWnd = WinRT.Interop.WindowNative.GetWindowHandle(this);
    WindowId myWndId = Microsoft.UI.Win32Interop.GetWindowIdFromWindow(hWnd);
    return AppWindow.GetFromWindowId(myWndId);
}
```

4.	Involde above fuction in public MainWindow():
```csharp
m_appWindow = GetAppWindowForCurrentWindow();
```

5.	To set the app window to one of those modes, we still need to invoke the SetPresenter method using the WinAppSDK window object m_appWindow: 
```csharp
private void SwitchPresenter(object sender, RoutedEventArgs e)
{
    m_appWindow.SetPresenter(AppWindowPresenterKind.CompactOverlay);
}
```

6.	Modify the XAML file for the MenuFlyouItem so we can use it to trigger the SwitchPresenter function:
```xml
<MenuFlyoutItem Text="Compact Overlay" Click="SwitchPresenter"/>
```



The preceding code gets the window Id for the hwnd and then uses that window Id to get the current AppWindow. This will create the WinAppSDK window layer that gives you access to all the window customization features of the app window. If you run your app again and click the drop-down button and choose Compact Overlay, the app window will not allow other app windows to overlap on top of it.

Just like that, you can see how we can leverage the amazing Windowing features to customize windowing options for your app. Repeat the same steps to implement the Fullscreen mode. Now you can use WinAppSDK to your advantage to create beautiful, complex, and fully-featured apps. To learn more about Windowing, see Manage app windows for additional information on what you can do with this feature. 

See my code here
